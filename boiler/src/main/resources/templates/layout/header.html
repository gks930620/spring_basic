<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head th:fragment="headerStyle">
    <!-- Material Icons -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <!-- Material Design CSS -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: #fafafa;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header Styles */
        .app-header {
            background-color: #6200ea;
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 64px;
        }

        .header-logo {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 20px;
            font-weight: 500;
            text-decoration: none;
            color: white;
            cursor: pointer;
        }

        .header-logo .material-icons {
            font-size: 28px;
        }

        .header-nav {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .nav-item {
            padding: 8px 16px;
            border-radius: 4px;
            text-decoration: none;
            color: white;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: background-color 0.2s;
            font-size: 14px;
            font-weight: 500;
        }

        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .nav-item.active {
            background-color: rgba(255, 255, 255, 0.2);
        }

        .nav-item .material-icons {
            font-size: 20px;
        }

        /* User Menu */
        .user-menu {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: 16px;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            font-size: 14px;
        }

        .user-info .material-icons {
            font-size: 20px;
        }

        .login-btn {
            padding: 8px 16px;
            background-color: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: background-color 0.2s;
        }

        .login-btn:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }

        .logout-btn {
            padding: 6px 12px;
            background: none;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            border-radius: 16px;
            font-size: 13px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .logout-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        /* Mobile Menu */
        .mobile-menu-btn {
            display: none;
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            padding: 8px;
        }

        .mobile-menu-btn .material-icons {
            font-size: 24px;
        }

        @media (max-width: 768px) {
            .header-nav {
                display: none;
                position: absolute;
                top: 64px;
                left: 0;
                right: 0;
                background-color: #6200ea;
                flex-direction: column;
                padding: 8px;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            }

            .header-nav.mobile-open {
                display: flex;
            }

            .nav-item {
                width: 100%;
                justify-content: flex-start;
            }

            .mobile-menu-btn {
                display: block;
            }
        }

        /* Main Content */
        .main-content {
            flex: 1;
            max-width: 1200px;
            width: 100%;
            margin: 0 auto;
            padding: 24px 16px;
        }
    </style>
</head>
<body>
    <header class="app-header" th:fragment="header">
        <div class="header-container">
            <a href="/" class="header-logo">
                <span class="material-icons">code</span>
                <span>Boilerplate</span>
            </a>

            <nav class="header-nav" id="headerNav">

                <a href="/community" class="nav-item" data-path="/community">
                    <span class="material-icons">forum</span>
                    <span>ì»¤ë®¤ë‹ˆí‹°</span>
                </a>

            </nav>

            <div class="user-menu" id="userMenu">
                <!-- ë¡œê·¸ì¸ ì „ (ê¸°ë³¸ê°’ - JavaScriptë¡œ ì—…ë°ì´íŠ¸ë¨) -->
                <a href="/login" class="login-btn" id="loginBtn" style="display: none;">
                    <span class="material-icons">login</span>
                    <span>ë¡œê·¸ì¸</span>
                </a>

                <!-- ë¡œê·¸ì¸ í›„ (JavaScriptë¡œ ì—…ë°ì´íŠ¸ë¨) -->
                <div id="loggedInMenu" style="display: none; align-items: center; gap: 8px;">
                    <a href="/mypage" class="nav-item">
                        <span class="material-icons">person</span>
                        <span>ë§ˆì´í˜ì´ì§€</span>
                    </a>
                    <div class="user-info">
                        <span class="material-icons">account_circle</span>
                        <span id="headerNickname"></span>
                    </div>
                    <button type="button" class="logout-btn" onclick="handleLogout()">ë¡œê·¸ì•„ì›ƒ</button>
                </div>

                <!-- ë¡œë”© ì¤‘ (ì´ˆê¸° ìƒíƒœ) -->
                <div id="authLoading" style="display: flex; align-items: center; color: rgba(255,255,255,0.7); font-size: 14px;">
                    <span>...</span>
                </div>
            </div>

            <button class="mobile-menu-btn" id="mobileMenuBtn">
                <span class="material-icons">menu</span>
            </button>
        </div>
    </header>

    <script th:fragment="headerScript">
        // ========== í—¤ë” ë¡œê·¸ì¸ ìƒíƒœ ì—…ë°ì´íŠ¸ ==========

        /**
         * í—¤ë”ì˜ ë¡œê·¸ì¸ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸
         */
        let headerLoginStatusUpdated = false; // ì¤‘ë³µ ì—…ë°ì´íŠ¸ ë°©ì§€ í”Œë˜ê·¸

        function updateHeaderLoginStatus(isLoggedIn, nickname = '') {
            const loginBtn = document.getElementById('loginBtn');
            const loggedInMenu = document.getElementById('loggedInMenu');
            const authLoading = document.getElementById('authLoading');
            const headerNickname = document.getElementById('headerNickname');

            if (authLoading) authLoading.style.display = 'none';

            if (isLoggedIn) {
                if (loginBtn) loginBtn.style.display = 'none';
                if (loggedInMenu) loggedInMenu.style.display = 'flex';
                if (headerNickname) headerNickname.textContent = nickname;
            } else {
                if (loginBtn) loginBtn.style.display = 'flex';
                if (loggedInMenu) loggedInMenu.style.display = 'none';
            }

            headerLoginStatusUpdated = true;
        }

        /**
         * í—¤ë” ë¡œê·¸ì¸ ìƒíƒœ ì²´í¬ (í˜ì´ì§€ ë¡œë“œ ì‹œ ìë™ ì‹¤í–‰)
         */
        async function checkHeaderLoginStatus() {
            // ì´ë¯¸ ë‹¤ë¥¸ ê³³ì—ì„œ ì—…ë°ì´íŠ¸í–ˆìœ¼ë©´ ìŠ¤í‚µ
            if (headerLoginStatusUpdated) return;

            try {
                const response = await authFetch('/api/my/info', { credentials: 'include' });
                if (response && response.ok) {
                    const result = await response.json();
                    updateHeaderLoginStatus(true, result.data.nickname);
                } else {
                    updateHeaderLoginStatus(false);
                }
            } catch (e) {
                updateHeaderLoginStatus(false);
            }
        }

        // ========== í† í° ì¬ë°œê¸‰ ê´€ë ¨ ==========
        let isRefreshing = false; // í† í° ì¬ë°œê¸‰ ì¤‘ì¸ì§€ ì—¬ë¶€
        let refreshSubscribers = []; // ì¬ë°œê¸‰ ëŒ€ê¸° ì¤‘ì¸ ìš”ì²­ë“¤

        /**
         * í† í° ì¬ë°œê¸‰ ì™„ë£Œ í›„ ëŒ€ê¸° ì¤‘ì¸ ìš”ì²­ë“¤ ì²˜ë¦¬
         */
        function onTokenRefreshed() {
            refreshSubscribers.forEach(callback => callback());
            refreshSubscribers = [];
        }

        /**
         * í† í° ì¬ë°œê¸‰ ì‹¤íŒ¨ ì‹œ ëŒ€ê¸° ì¤‘ì¸ ìš”ì²­ë“¤ ì²˜ë¦¬
         */
        function onTokenRefreshFailed() {
            refreshSubscribers = [];
        }

        /**
         * í† í° ì¬ë°œê¸‰ ì‹œë„
         * @returns {Promise<boolean>} ì„±ê³µ ì—¬ë¶€
         */
        async function tryRefreshToken() {
            try {
                console.log('ğŸ”„ í† í° ì¬ë°œê¸‰ ì‹œë„...');

                const response = await fetch('/api/refresh/reissue', {
                    method: 'POST',
                    credentials: 'include' // ì¿ í‚¤ í¬í•¨ (refresh_token)
                });

                console.log('ğŸ“¡ ì¬ë°œê¸‰ ì‘ë‹µ ìƒíƒœ:', response.status);

                if (response.ok) {
                    const result = await response.json();
                    console.log('âœ… í† í° ì¬ë°œê¸‰ ì„±ê³µ:', result);
                    return true;
                } else {
                    const error = await response.json();
                    console.log('âŒ í† í° ì¬ë°œê¸‰ ì‹¤íŒ¨:', error.errorCode, error.message);
                    return false;
                }
            } catch (error) {
                console.error('âŒ í† í° ì¬ë°œê¸‰ ì—ëŸ¬:', error);
                return false;
            }
        }

        // ========== ê³µí†µ API ì—ëŸ¬ ì²˜ë¦¬ ìœ í‹¸ë¦¬í‹° ==========

        /**
         * API ì—ëŸ¬ ì‘ë‹µ ì²˜ë¦¬
         * @param {Response} response - fetch ì‘ë‹µ ê°ì²´
         * @returns {Promise<Object>} ì—ëŸ¬ ì •ë³´ ê°ì²´
         */
        async function handleApiError(response) {
            try {
                const errorData = await response.json();
                return {
                    status: response.status,
                    message: errorData.message || 'ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
                    errorCode: errorData.errorCode || 'UNKNOWN_ERROR',
                    errors: errorData.errors || null
                };
            } catch (e) {
                return {
                    status: response.status,
                    message: getDefaultErrorMessage(response.status),
                    errorCode: 'UNKNOWN_ERROR',
                    errors: null
                };
            }
        }

        /**
         * HTTP ìƒíƒœ ì½”ë“œë³„ ê¸°ë³¸ ì—ëŸ¬ ë©”ì‹œì§€
         */
        function getDefaultErrorMessage(status) {
            switch (status) {
                case 400: return 'ì˜ëª»ëœ ìš”ì²­ì…ë‹ˆë‹¤.';
                case 401: return 'ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.';
                case 403: return 'ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.';
                case 404: return 'ìš”ì²­í•œ ë¦¬ì†ŒìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';
                case 409: return 'ì´ë¯¸ ì²˜ë¦¬ëœ ìš”ì²­ì…ë‹ˆë‹¤.';
                case 500: return 'ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
                default: return 'ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
            }
        }

        /**
         * ì—ëŸ¬ ë©”ì‹œì§€ í‘œì‹œ ë° ë¦¬ë‹¤ì´ë ‰íŠ¸ ì²˜ë¦¬
         * @param {Object} error - ì—ëŸ¬ ì •ë³´ ê°ì²´
         * @param {Object} options - ì˜µì…˜ (redirect: boolean)
         */
        function showApiError(error, options = {}) {
            // 401ì¸ ê²½ìš° ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸
            if (error.status === 401 && options.redirectOnUnauthorized !== false) {
                alert(error.message || 'ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.');
                window.location.href = '/login';
                return;
            }

            // ìœ íš¨ì„± ê²€ì¦ ì—ëŸ¬ì¸ ê²½ìš° ìƒì„¸ ë©”ì‹œì§€ í‘œì‹œ
            if (error.errors && error.errors.length > 0) {
                const errorMessages = error.errors.map(e => `${e.field}: ${e.message}`).join('\n');
                alert(`${error.message}\n\n${errorMessages}`);
                return;
            }

            // ì¼ë°˜ ì—ëŸ¬ ë©”ì‹œì§€ í‘œì‹œ
            alert(error.message);
        }

        /**
         * API í˜¸ì¶œ ë˜í¼ í•¨ìˆ˜ (í† í° ë§Œë£Œ ì‹œ ìë™ ì¬ë°œê¸‰ + ì¬ì‹œë„)
         * @param {string} url - API URL
         * @param {Object} options - fetch ì˜µì…˜
         * @returns {Promise<Object>} API ì‘ë‹µ
         */
        async function callApi(url, options = {}) {
            const defaultOptions = {
                credentials: 'include',
                headers: {
                    'Content-Type': 'application/json',
                    ...options.headers
                }
            };

            const mergedOptions = { ...defaultOptions, ...options };

            let response = await fetch(url, mergedOptions);

            // 401 ì—ëŸ¬ì´ê³  TOKEN_EXPIREDì¸ ê²½ìš° í† í° ì¬ë°œê¸‰ ì‹œë„
            if (response.status === 401) {
                const clonedResponse = response.clone();
                try {
                    const errorData = await clonedResponse.json();

                    if (errorData.errorCode === 'TOKEN_EXPIRED') {
                        console.log('ğŸ”‘ Access Token ë§Œë£Œ - ì¬ë°œê¸‰ ì‹œë„');

                        // ì´ë¯¸ ì¬ë°œê¸‰ ì¤‘ì´ë©´ ëŒ€ê¸°
                        if (isRefreshing) {
                            return new Promise((resolve, reject) => {
                                refreshSubscribers.push(async () => {
                                    try {
                                        const retryResponse = await fetch(url, mergedOptions);
                                        if (!retryResponse.ok) {
                                            const error = await handleApiError(retryResponse);
                                            reject(error);
                                        } else {
                                            resolve(await retryResponse.json());
                                        }
                                    } catch (e) {
                                        reject(e);
                                    }
                                });
                            });
                        }

                        isRefreshing = true;

                        const refreshSuccess = await tryRefreshToken();

                        isRefreshing = false;

                        if (refreshSuccess) {
                            // ì¬ë°œê¸‰ ì„±ê³µ - ëŒ€ê¸° ì¤‘ì¸ ìš”ì²­ë“¤ ì²˜ë¦¬
                            onTokenRefreshed();

                            // ì›ë˜ ìš”ì²­ ì¬ì‹œë„
                            console.log('ğŸ”„ ì›ë˜ ìš”ì²­ ì¬ì‹œë„:', url);
                            response = await fetch(url, mergedOptions);
                        } else {
                            // ì¬ë°œê¸‰ ì‹¤íŒ¨ - ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ
                            onTokenRefreshFailed();
                            alert('ì„¸ì…˜ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”.');
                            window.location.href = '/login';
                            throw { status: 401, message: 'ì„¸ì…˜ ë§Œë£Œ', errorCode: 'SESSION_EXPIRED' };
                        }
                    }
                } catch (e) {
                    // JSON íŒŒì‹± ì‹¤íŒ¨ ì‹œ ì›ë˜ response ì‚¬ìš©
                    if (e.status) throw e; // ìš°ë¦¬ê°€ ë˜ì§„ ì—ëŸ¬ë©´ ë‹¤ì‹œ throw
                }
            }

            if (!response.ok) {
                const error = await handleApiError(response);
                throw error;
            }

            // 204 No Contentì¸ ê²½ìš° ë¹ˆ ê°ì²´ ë°˜í™˜
            if (response.status === 204) {
                return { success: true };
            }

            const result = await response.json();
            return result;
        }

        /**
         * ì¸ì¦ì´ í•„ìš”í•œ fetch ë˜í¼ (í† í° ë§Œë£Œ ì‹œ ìë™ ì¬ë°œê¸‰)
         * ê¸°ì¡´ fetchë¥¼ ëŒ€ì²´í•˜ì—¬ ì‚¬ìš©
         */
        async function authFetch(url, options = {}) {
            const defaultOptions = {
                credentials: 'include'
            };

            const mergedOptions = { ...defaultOptions, ...options };

            console.log('ğŸŒ authFetch ìš”ì²­:', url);
            let response = await fetch(url, mergedOptions);
            console.log('ğŸ“¡ authFetch ì‘ë‹µ:', response.status);

            // 401 ì—ëŸ¬ì´ê³  TOKEN_EXPIREDì¸ ê²½ìš° í† í° ì¬ë°œê¸‰ ì‹œë„
            if (response.status === 401) {
                const clonedResponse = response.clone();
                try {
                    const errorData = await clonedResponse.json();
                    console.log('ğŸ” 401 ì—ëŸ¬ ìƒì„¸:', errorData);

                    if (errorData.errorCode === 'TOKEN_EXPIRED') {
                        console.log('ğŸ”‘ Access Token ë§Œë£Œ - ì¬ë°œê¸‰ ì‹œë„');

                        if (!isRefreshing) {
                            isRefreshing = true;
                            const refreshSuccess = await tryRefreshToken();
                            isRefreshing = false;

                            if (refreshSuccess) {
                                onTokenRefreshed();
                                // ì¿ í‚¤ê°€ ì ìš©ë  ì‹œê°„ì„ ì•½ê°„ ì¤Œ
                                await new Promise(resolve => setTimeout(resolve, 50));
                                // ì›ë˜ ìš”ì²­ ì¬ì‹œë„
                                console.log('ğŸ”„ ì›ë˜ ìš”ì²­ ì¬ì‹œë„:', url);
                                const retryResponse = await fetch(url, mergedOptions);
                                console.log('ğŸ“¡ ì¬ì‹œë„ ì‘ë‹µ:', retryResponse.status);
                                return retryResponse;
                            } else {
                                // ì¬ë°œê¸‰ ì‹¤íŒ¨ - ì›ë˜ ì‘ë‹µ ë°˜í™˜ (í˜¸ì¶œìê°€ ì²˜ë¦¬)
                                onTokenRefreshFailed();
                                console.log('âŒ ì¬ë°œê¸‰ ì‹¤íŒ¨ - ì›ë˜ 401 ì‘ë‹µ ë°˜í™˜');
                                return response;
                            }
                        } else {
                            // ì´ë¯¸ ì¬ë°œê¸‰ ì¤‘ì´ë©´ ëŒ€ê¸°
                            console.log('â³ ì´ë¯¸ ì¬ë°œê¸‰ ì¤‘ - ëŒ€ê¸°');
                            return new Promise((resolve) => {
                                refreshSubscribers.push(async () => {
                                    await new Promise(r => setTimeout(r, 50));
                                    resolve(await fetch(url, mergedOptions));
                                });
                            });
                        }
                    } else {
                        console.log('ğŸš« TOKEN_EXPIREDê°€ ì•„ë‹˜, ê·¸ëƒ¥ 401:', errorData.errorCode);
                    }
                } catch (e) {
                    console.log('âš ï¸ JSON íŒŒì‹± ì‹¤íŒ¨, ì›ë˜ response ë°˜í™˜');
                }
            }

            return response;
        }

        // ========== ê¸°ì¡´ ì½”ë“œ ==========

        // Set active nav item based on current path
        function setActiveNavItem() {
            const currentPath = window.location.pathname;
            const navItems = document.querySelectorAll('.nav-item[data-path]');

            navItems.forEach(item => {
                const itemPath = item.getAttribute('data-path');
                if (currentPath.startsWith(itemPath)) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
        }

        // Mobile menu toggle
        document.getElementById('mobileMenuBtn')?.addEventListener('click', function() {
            const nav = document.getElementById('headerNav');
            nav.classList.toggle('mobile-open');
        });

        // Logout handler
        async function handleLogout() {
            try {
                const response = await fetch('/api/logout', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    credentials: 'include' // ì¿ í‚¤ í¬í•¨
                });

                if (response.ok) {
                    // ì„œë²„ì—ì„œ ì¿ í‚¤ë¥¼ ë§Œë£Œì‹œì¼°ìœ¼ë¯€ë¡œ, í´ë¼ì´ì–¸íŠ¸ëŠ” í™ˆìœ¼ë¡œ ì´ë™
                    window.location.href = '/';
                } else {
                    const error = await response.json();
                    console.log('Logout failed:', error);
                    alert('ë¡œê·¸ì•„ì›ƒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                }
            } catch (error) {
                console.log('Logout error:', error);
                alert('ë¡œê·¸ì•„ì›ƒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            }
        }

        // í˜ì´ì§€ ë¡œë“œì‹œ active ë©”ë‰´ ì„¤ì • ë° í—¤ë” ë¡œê·¸ì¸ ìƒíƒœ ì²´í¬
        document.addEventListener('DOMContentLoaded', () => {
            setActiveNavItem();

            // ë¡œê·¸ì¸/íšŒì›ê°€ì… í˜ì´ì§€ê°€ ì•„ë‹Œ ê²½ìš°ì—ë§Œ ë¡œê·¸ì¸ ìƒíƒœ ì²´í¬
            if (window.location.pathname !== '/login' && window.location.pathname !== '/signup') {
                checkHeaderLoginStatus();
            } else {
                // ë¡œê·¸ì¸/íšŒì›ê°€ì… í˜ì´ì§€ì—ì„œëŠ” ë¡œê·¸ì¸ ë²„íŠ¼ í‘œì‹œ
                updateHeaderLoginStatus(false);
            }
        });
    </script>

